# 0.6.7

## Overview

- **Critical bug fix**: SIGSEGV crash during executable cleanup
- **New Feature**: Variable Order Markov Model (VOMM) algorithm for process prediction
- **Defensive programming**: NULL guards to prevent double-free scenarios
- **Improvement**: Standardized debug logging for prediction algorithms

---

## Part 1: Bug Fixes

### Summary

| File            | Issue                                     | Severity | Fix                                      |
| --------------- | ----------------------------------------- | -------- | ---------------------------------------- |
| `state.c`       | Hash table key type mismatch              | Critical | Use `exe->path` instead of `exe` pointer |
| `state.c`       | Double-free crash in `preload_exe_free()` | Critical | Added NULL guards for all members        |
| `model_utils.c` | Crash on already-removed executables      | Critical | Verify hash table membership first       |

### Root Cause Analysis

The crash occurred during cleanup of deleted executables (commonly triggered by Steam/Proton temporary files).

**Error Pattern:**

```log
preload_state_unregister_exe: assertion 'g_hash_table_lookup (state->exes, exe)' failed
GLib: g_ptr_array_foreach: assertion 'array' failed
GLib: g_ptr_array_free: assertion 'array' failed
systemd: preload-ng.service: Main process exited, code=killed, status=11/SEGV
```

**Root Cause:** The hash table `state->exes` is created with string-based keys (`g_str_hash`/`g_str_equal`), but `preload_state_unregister_exe()` was using the `exe` pointer as the lookup key instead of `exe->path`.

### Detailed Fixes

#### 1. Hash Table Key Type Mismatch (`state.c`)

The core bug was a mismatch between the hash table's key type and the keys used in lookup/remove operations.

```c
// Before: using exe pointer as key (WRONG)
void preload_state_unregister_exe (preload_exe_t *exe)
{
  g_return_if_fail (g_hash_table_lookup (state->exes, exe));
  // ...
  g_hash_table_remove (state->exes, exe);
}

// After: using exe->path as key (CORRECT)
void preload_state_unregister_exe (preload_exe_t *exe)
{
  g_return_if_fail (exe && exe->path);
  g_return_if_fail (g_hash_table_lookup (state->exes, exe->path));
  // ...
  g_hash_table_remove (state->exes, exe->path);
}
```

The same fix was applied to `preload_state_register_exe()`.

#### 2. NULL Guards in `preload_exe_free()` (`state.c`)

When the unregister operation failed, the exe remained in the hash table with partially freed members. During daemon shutdown, `g_hash_table_destroy()` would trigger `preload_exe_free()` again, causing a double-free.

```c
// Before: no NULL checks
void preload_exe_free (preload_exe_t *exe)
{
  g_return_if_fail (exe);
  g_return_if_fail (exe->path);
  g_set_foreach (exe->exemaps, ...);  // Crash if exemaps is NULL
  g_set_foreach (exe->markovs, ...);  // Crash if markovs is NULL
  // ...
}

// After: defensive NULL guards
void preload_exe_free (preload_exe_t *exe)
{
  g_return_if_fail (exe);

  if (exe->exemaps) {
    g_set_foreach (exe->exemaps, (GFunc)preload_exemap_free, NULL);
    g_set_free (exe->exemaps);
    exe->exemaps = NULL;
  }
  // ... (similar guards for markovs and path)
  if (exe->path) {
    g_free (exe->path);
    exe->path = NULL;
  }
  g_free (exe);
}
```

#### 3. Safety Checks in `remove_invalid_exe()` (`model_utils.c`)

Added pre-removal validation to handle edge cases where an executable might already be removed from the hash table.

```c
static void
remove_invalid_exe(preload_exe_t *exe, cleanup_context_t *ctx)
{
  // Guard against exe that was already unregistered or has NULL path
  if (!exe || !exe->path) {
    return;
  }

  // Verify exe is still in the hash table before unregistering
  if (!g_hash_table_lookup(state->exes, exe->path)) {
    return;
  }

  preload_state_unregister_exe(exe);
  preload_exe_free(exe);
  ctx->removed_count++;
}
```

### Impact

- **SIGSEGV crash fixed**: Daemon no longer crashes when Steam/Proton temporary executables are deleted
- **Double-free prevention**: NULL guards prevent crashes from partially freed structures

---

## Part 2: New Features

### Summary

| Task | Files              | Description                                     |
| ---- | ------------------ | ----------------------------------------------- |
| 1    | `vomm.c`, `vomm.h` | Variable Order Markov Model (VOMM) algorithm    |
| 2    | `vomm.c`           | Hybrid PPM + Dependency Graph prediction Layers |
| 3    | `vomm.c`           | Global Frequency Fallback                       |

### Task 1: Variable Order Markov Model (VOMM) Algorithm

Implemented a new prediction algorithm based on the Variable Order Markov Model. This implementation uses a hybrid approach combining Prediction by Partial Matching (PPM) for sequence learning and a Dependency Graph (DG) for capturing immediate transitions. All references to the previous "Compact Prediction Tree (CPT)" terminologies have been renamed to VOMM to better reflect the underlying theoretical model.

**Key Components:**

- **Context Tree**: Learns sequences of execution events (History -> Prediction).
- **Hybrid Model**: Combines deep context prediction (Order-K) with simple bigram transitions (Order-1).
- **Global History**: Tracks the global sequence of application launches to identify patterns.

### Task 2: Hybrid Prediction Layers

The prediction engine now uses a multi-layered strategy to maximize hit rates:

```c
void vomm_predict(void) {
    /* LAYER 1: Context-Specific Prediction */
    // Predicts based on the sequence of recent events
    if (vomm_system.current_context &&
        g_hash_table_size(vomm_system.current_context->children) > 0) {
        predict_ppm(vomm_system.current_context);
        predict_dg_fallback(vomm_system.current_context);
    }

    // ...
}
```

This improves accuracy by understanding that `make` is often followed by `gcc`, while `firefox` might be followed by unrelated applications.

### Task 3: Global Frequency Fallback

As a safety net for when no sequential patterns are found, the system falls back to a global frequency model, ensuring that the most commonly used applications are still considered for preloading.

```c
/* LAYER 2: Global Frequency Fallback */
// Bid on ALL known executables based on their total observed frequency.
predict_global_frequency();
```

This ensures the daemon remains useful even with unpredictable user behavior, effectively functioning as a smart cache warmer for frequently used applications.

---

## Part 3: Code Refactoring

### Summary

| Task | Files                                | Description                       |
| ---- | ------------------------------------ | --------------------------------- |
| 1    | `preload-src/`                       | Source code reorganization        |
| 2    | `Makefile`, `scripts/`, `post_build` | Build system modernization        |
| 3    | `configure.ac`, `Makefile.am`        | Removal of Autotools build system |

### Task 1: Source Code Reorganization

The codebase has been significantly restructured to improve maintainability and logical separation of concerns. The flat file structure in `preload-src` has been organized into clear subdirectories:

- `daemon/`: Core daemon logic and main event loop.
- `config/`: Configuration parsing and management.
- `utils/`: shared utility functions and helper modules.

This modular approach ensures that related components are grouped together, making the codebase easier to navigate and extend.

### Task 2: Build System Modernization

The build system has been modernized to replace the complex Autotools setup with a streamlined Makefile and helper scripts.

- **Simplified Makefile**: A clean, hand-written Makefile now handles compilation, dependency tracking, and installation, reducing build complexity.
- **Improved Scripts**: Reference to `scripts/install.sh` and `scripts/build.sh` indicates a move towards standard shell scripts for lifecycle management.
- **Post-Build Automation**: A new `post_build/post_build` script handles configuration generation and runs basic smoke tests (debug mode, foreground mode) to ensure the binary is functional before using.

### Task 3: Removal of Autotools

Legacy build infrastructure has been removed:

- **Deprecated**: `configure.ac`, `Makefile.am`, and generated Autotools files have been deleted.
- **Benefit**: This drastically reduces the number of files in the repository and eliminates the need for users to have Autotools dependencies installed, simplifying the contribution and build process.

---

## Part 4: Improvements

### SummarY

| Task | Files                 | Description                                |
| ---- | --------------------- | ------------------------------------------ |
| 1    | `vomm.c`, `prophet.c` | Standardized debug logging for consistency |

### Task 1: Standardized Logging

Debug output from the prediction engines has been unified to facilitate easier debugging and analysis.

- **VOMM**: All logs now use the `[VOMM]` prefix (e.g., `[VOMM] Update: /usr/bin/firefox`).
- **Markov/Prophet**: Replaced raw `fprintf` calls with standard `g_debug`, using the `[Prophet]` prefix (e.g., `[Prophet] Final Bid: /usr/bin/firefox`).
